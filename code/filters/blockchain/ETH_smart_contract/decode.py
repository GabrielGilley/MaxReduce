#!/usr/bin/env python3
import json
from copy import copy
from web3.auto import w3
from web3 import Web3
from eth_utils import event_abi_to_log_topic, to_hex
import os
import random

path = os.path.abspath(os.path.dirname(__file__))
os.chdir(path)

def decode_tuple(t, target_field):
  output = dict()
  for i in range(len(t)):
    if isinstance(t[i], (bytes, bytearray)):
      output[target_field[i]['name']] = to_hex(t[i])
    elif isinstance(t[i], (tuple)):
      output[target_field[i]['name']] = decode_tuple(t[i], target_field[i]['components'])
    else:
      output[target_field[i]['name']] = t[i]
  return output

def decode_list_tuple(l, target_field):
  output = l
  for i in range(len(l)):
    output[i] = decode_tuple(l[i], target_field)
  return output

def decode_list(l):
  output = l
  for i in range(len(l)):
    if isinstance(l[i], (bytes, bytearray)):
      output[i] = to_hex(l[i])
    else:
      output[i] = l[i]
  return output

def convert_to_hex(arg, target_schema):
  output = dict()
  for k in arg:
    if isinstance(arg[k], (bytes, bytearray)):
      output[k] = to_hex(arg[k])
    elif isinstance(arg[k], (list)) and len(arg[k]) > 0:
      target = [a for a in target_schema if 'name' in a and a['name'] == k][0]
      if target['type'] == 'tuple[]':
        target_field = target['components']
        output[k] = decode_list_tuple(arg[k], target_field)
      else:
        output[k] = decode_list(arg[k])
    elif isinstance(arg[k], (tuple)):
      target_field = [a['components'] for a in target_schema if 'name' in a and a['name'] == k][0]
      output[k] = decode_tuple(arg[k], target_field)
    else:
      output[k] = arg[k]
  return output

def decode_array(param, all_params):
    sc_data = ''.join(all_params)
    start_ind = int(param, 16) * 2
    num_eles = int(sc_data[start_ind:start_ind+64], 16)
    used_param_start = (start_ind / 64)
    used_param_end = used_param_start + num_eles
    for x in range(int(used_param_start), int(used_param_end)+1):
        already_used[x] = True
    start_ind = start_ind + 64
    array = []
    print("array:")
    for i in range(num_eles):
        ele = sc_data[start_ind:start_ind+64]
        array.append(ele)
        start_ind = start_ind + 64
        print(f"\t{ele}")
    return array

#sc = "38ed1739000000000000000000000000000000000000000000000000000000009502f900000000000000000000000000000000000000000000a07e38bf71936cbe39594100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000003c02cebb49f6e8f1fc96158099ffa064bbfee38b00000000000000000000000000000000000000000000000000000000616e11230000000000000000000000000000000000000000000000000000000000000003000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000528b3e98c63ce21c6f680b713918e0f89dfae555"
#sc = "a9059cbb000000000000000000000000151251bb96ddc5e7b8c3cd47a6c471ac7b5e9c8f0000000000000000000000000000000000000000000000000000000cad93b7c2"
#sc = "ab834bab0000000000000000000000007be8076f4ea4a4ad08075c2508e481d6c946d12b0000000000000000000000002879271e69cbebbd2cefc8c3ed1a1feeb74a52f8000000000000000000000000c8890f267accbedcfbf5ca8c7b4bac60b6973d7300000000000000000000000000000000000000000000000000000000000000000000000000000000000000004e1f41613c9084fdb9e34e11fae9412427480e56000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007be8076f4ea4a4ad08075c2508e481d6c946d12b000000000000000000000000c8890f267accbedcfbf5ca8c7b4bac60b6973d7300000000000000000000000000000000000000000000000000000000000000000000000000000000000000005b3256965e7c3cf26e11fcaf296dfc8807c010730000000000000000000000004e1f41613c9084fdb9e34e11fae9412427480e560000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000fa000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000058d15e17628000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000061f721760000000000000000000000000000000000000000000000000000000000000000808858053d767abf1b093b7fd95c7490075791ac7b35fed3170b102b3f32076900000000000000000000000000000000000000000000000000000000000000fa000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000058d15e17628000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000061dd0e250000000000000000000000000000000000000000000000000000000062b38d4e408bf50ccbd04c53d63c8d42e7bda5431aa630df886e9e776935d0a76f11933f0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006a0000000000000000000000000000000000000000000000000000000000000074000000000000000000000000000000000000000000000000000000000000007e0000000000000000000000000000000000000000000000000000000000000088000000000000000000000000000000000000000000000000000000000000009200000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001bed891e9079c1793d601de70d6ed64bbe17f9e166a90721c2fbd3d7f8bcb0c5770ddc42424e81aa014fd5b0c019fa81234744d73b55b43ff7116e543e75e51f9ced891e9079c1793d601de70d6ed64bbe17f9e166a90721c2fbd3d7f8bcb0c5770ddc42424e81aa014fd5b0c019fa81234744d73b55b43ff7116e543e75e51f9c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006423b872dd00000000000000000000000000000000000000000000000000000000000000000000000000000000000000002879271e69cbebbd2cefc8c3ed1a1feeb74a52f80000000000000000000000000000000000000000000000000000000000001cc000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006423b872dd000000000000000000000000c8890f267accbedcfbf5ca8c7b4bac60b6973d7300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001cc000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006400000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"

types = {
    'uint256': {
        "variable_length": False,
        "length": 64
    }
}

def decode_sc_data(sc, contract_address):
    method = sc[:8]
    with open('signatures.json') as f:
        signatures = json.load(f)

    text_sig = None
    for signature in signatures:
        if signature['hex_signature'] == '0x' + method:
            text_sig = signature['text_signature']
            break

    if not text_sig:
        print(f'text sig not found for method {method}')
        return "FAIL"

    start = 8
    params = []
    bytes_remaining = len(sc) - start
    for x in range(int(bytes_remaining/64)):
        start_ind = int((x*64) + 8)
        params.append(sc[start_ind:start_ind+64])


    already_used = [False for _ in range(len(params))]


    param_types = text_sig.split('(')[1].split(')')[0].split(',')

    func_name = text_sig.split('(')[0]
    abi = {
        "name": func_name,
        "inputs": [],
        "outputs": [],
        "stateMutability": "view",
        "type": "function"
    }
    for param_type in param_types:
        new_input = {
            "internalType": param_type,
            "name": "unknown",
            "type": param_type
        }
        abi["inputs"].append(new_input)
    print("--------------entry---------------")
    ret = f"method:{text_sig}\nparameters: {json.dumps(abi['inputs'], indent=2)}"
    print(ret)
    print("----------------------------------")


    print('abi:')
    print(abi)
    print()
    contract = w3.eth.contract(address=Web3.toChecksumAddress(contract_address), abi=[abi])
    func_obj, func_params = contract.decode_function_input("0x" + sc)

    target_schema = [a['inputs'] for a in [abi] if 'name' in a and a['name'] == func_obj.fn_name][0]
    print('func_obj:')
    print(func_obj)
    print()
    print('func_params:')
    print(func_params)
    print()
    print('target_schema:')
    print(target_schema)
    print()
    decoded_func_params = convert_to_hex(func_params, target_schema)
    print('function called: ', func_obj.fn_name)
    print('arguments: ', json.dumps(json.loads(json.dumps(decoded_func_params)), indent=2))
    return ret
    '''

    i = 0
    param_type_ind = 0
    while True:
        try:
            while already_used[i]:
                i += 1
        except IndexError:
            break
        param = params[i]
        param_type = param_types[param_type_ind]
        param_type_ind += 1
        already_used[i] = True

        if param_type == 'uint256':
            val = int(param, 16)
            print(val)
        elif param_type == 'address[]':
            decode_array(param, params)
        elif param_type == 'address[14]':
            decode_array(param, params)
        elif param_type == 'address':
            print(param)
        else:
            raise NotImplementedError(f"No decoding option for type '{param_type}'")
    '''
